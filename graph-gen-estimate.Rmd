```{r}
is.acyclic <- function(A){
  ## A is an adjacency matrix
  ## i.e. a_ij = 1 if the edge i->j *is* in the graph
  ##      a_ij = 0 if the edge i->j *is not* in the graph
  if (nrow(A) == 1)
    return(TRUE)
  ## compute transitive closure
  H <- A
  diag(H) <- 1
  repeat {
    HH <- sign(H %*% H)
    if (all(HH == H)) 
      break
    else H <- HH
  }
  diag(H) <- 0
  ## h_ij =1 if there is a directed path from i to j
  l <- H[lower.tri(H)]
  u <- t(H)[lower.tri(t(H))]
  com <- (l & u)
  all(!com)
}

```

```{r}
gene = read.table('gene.txt', head=T)[, c(3,6,4,1)]
```

```{r}
### some inefficient useful functions
state_gen <- function(n){
  ###
  # get the combination for all state for the coordinates
  # param n: int number of nodes in a graph
  # return: a 3^n * n matrix, each row represents an n * n matrix
  num_pos_valued = (n^2-n)/2 # lower triangle
  pos = expand.grid(rep(list(1:3), num_pos_valued)) # one pos can contains 3 state
  pos
}

graph_gen <- function(pos, n){
  ###
  # according to the state gen, create multiple matrix
  # param pos: matrix, generated by state_gen
  # param n: int number of nodes in a graph
  # return matrix_gen: list list of all the matrix generated by state gen
  
  # utils function
  util_state_cal <- function(a_matrix, state, i, j ){
    switch(state,
           # state 1 means i->j
           {
             a_matrix[i,j] = 1
             a_matrix[j,i] = 0
           },
           # state 2 means no link between i and j
           {
             a_matrix[i,j] = 0
             a_matrix[j,i] = 0             
           },
           # state 3 means j->i
           {
             a_matrix[i,j] = 0
             a_matrix[j,i] = 1             
           }
           )
    a_matrix
  }
  
  num_matrix = dim(pos)[1]
  matrix_gen = list()
  for (k in 1:num_matrix) {
    tmp_matrix = matrix(0,n,n)  # generate empty n * n 0 matrix
    states = pos[k,]  # select state from pos
    val_pos = 1  # loop中第几个position
    for (i in 2:n) {
      for (j in 1:(i-1)) {
        tmp_matrix = util_state_cal(tmp_matrix, states[1,val_pos], i, j)
        val_pos = val_pos + 1
      }
    }
    
    matrix_gen[[k]] = tmp_matrix
  }
  
  matrix_gen
}
```

```{r}
graph_estimation <- function(a_graph, sample_data){
  ###
  # calculate BIC and estimate parameter for distribution
  # param a_graph: matrix, generated by graph_gen
  # param sample_data: data.frame, the data for samples
  # return summary: list contains bic and parameters for each node
  
  # check validity
  if (dim(a_graph)[2] != dim(sample_data)[2]){
    stop('Illegel argument exception, two parameter column size should equal')
  }
  
  # start from building returning list
  params = list()  # store fit for each nodes
  bics = list()  # store bic for each nodes, at the end store total bic
  total_bic = 0
  
  # get the name for all nodes
  node_name = colnames(sample_data)
  num_of_node = dim(a_graph)[2]
  N = dim(a_graph)[1] # num of sample
  
  # for column k in a_graph, the position where value == 1, we say those.. 
  # positions are pa(k), if length(pa(k)) is not 0, we perform lm, else we
  # just estimate the sample mean and variance, at the mean time, we calculate
  # BIC for this node, and record all the parameters to params and bic 
  for (k in 1:num_of_node) {
    pa_k_index = which(a_graph[,k]==1) 
    # if exist parent
    if (length(pa_k_index)){
      # create formula
      f <- as.formula(
        paste(node_name[k],
              paste(node_name[pa_k_index], collapse = '+'),
              sep = '~'))

      # run linear regression
      # all the info contains in fit, RSS can be calculated by sum(resid(fit)^2)
      fit <- lm(f, data = sample_data)  
      
      params[[node_name[k]]] = fit  # store params
      bic = N * log(1/N * sum(resid(fit)^2)) +
        length(pa_k_index) * log(N)

      bics[[node_name[k]]] = bic   # store bics
      total_bic = total_bic + bic
    } else {
      node_data = sample_data[ ,k]
      b = mean(node_data)
      v = var(node_data)
      tmp_summary = list('b'=b, 'v'=v)
      params[[node_name[k]]] = tmp_summary

      bic = N * log(v)  # no parent node, so bic change to this formula, b:mean
      bics[[node_name[k]]] = bic
      total_bic = total_bic + bic
    }
  }
  
  # combine the report
  result = list()
  result[['params']] = params
  result[['bics']] = bics
  result[['total_bic']] = total_bic

  result
}
```


```{r}
# test only
pos = state_gen(4)
graph = graph_gen(pos, 4)
```

```{r}
graph[[234]]
```

```{r}
result = graph_estimation(graph[[234]], gene)
```

```{r}
result$params
```
```{r}
min_bic = .Machine$integer.max
min_graph = NA
for (g in graph) {
  if (is.acyclic(g)){
    result = graph_estimation(g, gene)
    if (result$total_bic < min_bic){
      min_bic = result$total_bic
      min_graph = g
    }
  }
}

print(min_bic)
print(min_graph)
```






`


